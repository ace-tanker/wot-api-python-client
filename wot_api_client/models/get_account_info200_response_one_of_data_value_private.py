# coding: utf-8

"""
    World of Tanks

    OpenAPI specification for the Wargaming.net Public API. The official Wargaming.net Public API documentation can be found at the Wargaming [Developer's room](https://developers.wargaming.net/).

    The version of the OpenAPI document: 1.0.0
    Contact: contact@ace-tanker.net
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from wot_api_client.models.get_account_info200_response_one_of_data_value_private_boosters_value import GetAccountInfo200ResponseOneOfDataValuePrivateBoostersValue
from wot_api_client.models.get_account_info200_response_one_of_data_value_private_grouped_contacts import GetAccountInfo200ResponseOneOfDataValuePrivateGroupedContacts
from wot_api_client.models.get_account_info200_response_one_of_data_value_private_rented_value import GetAccountInfo200ResponseOneOfDataValuePrivateRentedValue
from wot_api_client.models.get_account_info200_response_one_of_data_value_private_restrictions import GetAccountInfo200ResponseOneOfDataValuePrivateRestrictions
from typing import Optional, Set
from typing_extensions import Self

class GetAccountInfo200ResponseOneOfDataValuePrivate(BaseModel):
    """
    Player's private data
    """ # noqa: E501
    personal_missions: Optional[Dict[str, StrictStr]] = Field(default=None, description="Personal Missions Progress. The key is a task id, the value is a status.  Possible statuses:   * NONE - a mission is unavailable  * UNLOCKED - a mission is available  * NEED_GET_MAIN_REWARD - the main reward has not been received  * MAIN_REWARD_GOTTEN - the main reward has been received  * NEED_GET_ADD_REWARD - additional reward has not been received  * NEED_GET_ALL_REWARDS - no rewards have been received  * ALL_REWARDS_GOTTEN - all rewards have been received .")
    gold: StrictInt = Field(description="Gold")
    battle_life_time: StrictInt = Field(description="Overall battle life time in seconds")
    free_xp: StrictInt = Field(description="Free Experience")
    credits: StrictInt = Field(description="Credits")
    premium_expires_at: StrictInt = Field(description="Premium Account expiration time")
    is_premium: StrictBool = Field(description="Indicates if the account is Premium Account")
    rented: Optional[Dict[str, Optional[GetAccountInfo200ResponseOneOfDataValuePrivateRentedValue]]] = Field(default=None, description="Vehicle Rental.")
    grouped_contacts: Optional[GetAccountInfo200ResponseOneOfDataValuePrivateGroupedContacts] = None
    restrictions: Optional[GetAccountInfo200ResponseOneOfDataValuePrivateRestrictions]
    is_bound_to_phone: StrictBool = Field(description="Indicates if mobile phone number was added to the account")
    boosters: Optional[Dict[str, Optional[GetAccountInfo200ResponseOneOfDataValuePrivateBoostersValue]]] = Field(default=None, description="Personal Reserves.")
    garage: Optional[List[StrictInt]] = Field(default=None, description="Vehicles in the Garage.")
    ban_info: Optional[StrictStr] = Field(description="Account ban details")
    ban_time: Optional[StrictInt] = Field(description="End time of account ban")
    bonds: StrictInt = Field(description="Bonds")
    __properties: ClassVar[List[str]] = ["personal_missions", "gold", "battle_life_time", "free_xp", "credits", "premium_expires_at", "is_premium", "rented", "grouped_contacts", "restrictions", "is_bound_to_phone", "boosters", "garage", "ban_info", "ban_time", "bonds"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GetAccountInfo200ResponseOneOfDataValuePrivate from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in rented (dict)
        _field_dict = {}
        if self.rented:
            for _key_rented in self.rented:
                if self.rented[_key_rented]:
                    _field_dict[_key_rented] = self.rented[_key_rented].to_dict()
            _dict['rented'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of grouped_contacts
        if self.grouped_contacts:
            _dict['grouped_contacts'] = self.grouped_contacts.to_dict()
        # override the default output from pydantic by calling `to_dict()` of restrictions
        if self.restrictions:
            _dict['restrictions'] = self.restrictions.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in boosters (dict)
        _field_dict = {}
        if self.boosters:
            for _key_boosters in self.boosters:
                if self.boosters[_key_boosters]:
                    _field_dict[_key_boosters] = self.boosters[_key_boosters].to_dict()
            _dict['boosters'] = _field_dict
        # set to None if rented (nullable) is None
        # and model_fields_set contains the field
        if self.rented is None and "rented" in self.model_fields_set:
            _dict['rented'] = None

        # set to None if grouped_contacts (nullable) is None
        # and model_fields_set contains the field
        if self.grouped_contacts is None and "grouped_contacts" in self.model_fields_set:
            _dict['grouped_contacts'] = None

        # set to None if restrictions (nullable) is None
        # and model_fields_set contains the field
        if self.restrictions is None and "restrictions" in self.model_fields_set:
            _dict['restrictions'] = None

        # set to None if boosters (nullable) is None
        # and model_fields_set contains the field
        if self.boosters is None and "boosters" in self.model_fields_set:
            _dict['boosters'] = None

        # set to None if ban_info (nullable) is None
        # and model_fields_set contains the field
        if self.ban_info is None and "ban_info" in self.model_fields_set:
            _dict['ban_info'] = None

        # set to None if ban_time (nullable) is None
        # and model_fields_set contains the field
        if self.ban_time is None and "ban_time" in self.model_fields_set:
            _dict['ban_time'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GetAccountInfo200ResponseOneOfDataValuePrivate from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "personal_missions": obj.get("personal_missions"),
            "gold": obj.get("gold"),
            "battle_life_time": obj.get("battle_life_time"),
            "free_xp": obj.get("free_xp"),
            "credits": obj.get("credits"),
            "premium_expires_at": obj.get("premium_expires_at"),
            "is_premium": obj.get("is_premium"),
            "rented": dict(
                (_k, GetAccountInfo200ResponseOneOfDataValuePrivateRentedValue.from_dict(_v))
                for _k, _v in obj["rented"].items()
            )
            if obj.get("rented") is not None
            else None,
            "grouped_contacts": GetAccountInfo200ResponseOneOfDataValuePrivateGroupedContacts.from_dict(obj["grouped_contacts"]) if obj.get("grouped_contacts") is not None else None,
            "restrictions": GetAccountInfo200ResponseOneOfDataValuePrivateRestrictions.from_dict(obj["restrictions"]) if obj.get("restrictions") is not None else None,
            "is_bound_to_phone": obj.get("is_bound_to_phone"),
            "boosters": dict(
                (_k, GetAccountInfo200ResponseOneOfDataValuePrivateBoostersValue.from_dict(_v))
                for _k, _v in obj["boosters"].items()
            )
            if obj.get("boosters") is not None
            else None,
            "garage": obj.get("garage"),
            "ban_info": obj.get("ban_info"),
            "ban_time": obj.get("ban_time"),
            "bonds": obj.get("bonds")
        })
        return _obj


