# coding: utf-8

"""
    World of Tanks

    OpenAPI specification for the Wargaming.net Public API. The official Wargaming.net Public API documentation can be found at the Wargaming [Developer's room](https://developers.wargaming.net/).

    The version of the OpenAPI document: 1.0.0
    Contact: contact@ace-tanker.net
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt
from typing import Any, ClassVar, Dict, List, Optional
from wot_api_client.models.tanks_stats_data_value_inner_all import TanksStatsDataValueInnerAll
from wot_api_client.models.tanks_stats_data_value_inner_clan import TanksStatsDataValueInnerClan
from wot_api_client.models.tanks_stats_data_value_inner_company import TanksStatsDataValueInnerCompany
from wot_api_client.models.tanks_stats_data_value_inner_epic import TanksStatsDataValueInnerEpic
from wot_api_client.models.tanks_stats_data_value_inner_fallout import TanksStatsDataValueInnerFallout
from wot_api_client.models.tanks_stats_data_value_inner_globalmap import TanksStatsDataValueInnerGlobalmap
from wot_api_client.models.tanks_stats_data_value_inner_random import TanksStatsDataValueInnerRandom
from wot_api_client.models.tanks_stats_data_value_inner_ranked10x10 import TanksStatsDataValueInnerRanked10x10
from wot_api_client.models.tanks_stats_data_value_inner_ranked_battles import TanksStatsDataValueInnerRankedBattles
from wot_api_client.models.tanks_stats_data_value_inner_regular_team import TanksStatsDataValueInnerRegularTeam
from wot_api_client.models.tanks_stats_data_value_inner_stronghold_defense import TanksStatsDataValueInnerStrongholdDefense
from wot_api_client.models.tanks_stats_data_value_inner_stronghold_skirmish import TanksStatsDataValueInnerStrongholdSkirmish
from wot_api_client.models.tanks_stats_data_value_inner_team import TanksStatsDataValueInnerTeam
from typing import Optional, Set
from typing_extensions import Self

class TanksStatsDataValueInner(BaseModel):
    """
    TanksStatsDataValueInner
    """ # noqa: E501
    account_id: StrictInt = Field(description="Player account ID")
    tank_id: StrictInt = Field(description="Vehicle ID")
    all: Optional[TanksStatsDataValueInnerAll]
    company: Optional[TanksStatsDataValueInnerCompany]
    stronghold_defense: Optional[TanksStatsDataValueInnerStrongholdDefense]
    stronghold_skirmish: Optional[TanksStatsDataValueInnerStrongholdSkirmish]
    clan: Optional[TanksStatsDataValueInnerClan]
    random: Optional[TanksStatsDataValueInnerRandom] = None
    fallout: Optional[TanksStatsDataValueInnerFallout] = None
    team: Optional[TanksStatsDataValueInnerTeam]
    regular_team: Optional[TanksStatsDataValueInnerRegularTeam]
    globalmap: Optional[TanksStatsDataValueInnerGlobalmap]
    epic: Optional[TanksStatsDataValueInnerEpic] = None
    ranked_battles: Optional[TanksStatsDataValueInnerRankedBattles] = None
    max_xp: StrictInt = Field(description="Maximum experience per battle")
    max_frags: StrictInt = Field(description="Maximum destroyed in battle")
    frags: Optional[Dict[str, StrictInt]] = Field(description="Details on vehicles destroyed. This data requires a valid access_token for the specified account.")
    in_garage: Optional[StrictBool] = Field(description="Availability of vehicle in the Garage. This data requires a valid access_token for the specified account.")
    mark_of_mastery: StrictInt = Field(description="Mastery Badges:   * 0 — None  * 1 — 3rd Class   * 2 — 2nd Class  * 3 — 1st Class  * 4 — Ace Tanker")
    ranked_10x10: Optional[TanksStatsDataValueInnerRanked10x10] = None
    __properties: ClassVar[List[str]] = ["account_id", "tank_id", "all", "company", "stronghold_defense", "stronghold_skirmish", "clan", "random", "fallout", "team", "regular_team", "globalmap", "epic", "ranked_battles", "max_xp", "max_frags", "frags", "in_garage", "mark_of_mastery", "ranked_10x10"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TanksStatsDataValueInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of all
        if self.all:
            _dict['all'] = self.all.to_dict()
        # override the default output from pydantic by calling `to_dict()` of company
        if self.company:
            _dict['company'] = self.company.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stronghold_defense
        if self.stronghold_defense:
            _dict['stronghold_defense'] = self.stronghold_defense.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stronghold_skirmish
        if self.stronghold_skirmish:
            _dict['stronghold_skirmish'] = self.stronghold_skirmish.to_dict()
        # override the default output from pydantic by calling `to_dict()` of clan
        if self.clan:
            _dict['clan'] = self.clan.to_dict()
        # override the default output from pydantic by calling `to_dict()` of random
        if self.random:
            _dict['random'] = self.random.to_dict()
        # override the default output from pydantic by calling `to_dict()` of fallout
        if self.fallout:
            _dict['fallout'] = self.fallout.to_dict()
        # override the default output from pydantic by calling `to_dict()` of team
        if self.team:
            _dict['team'] = self.team.to_dict()
        # override the default output from pydantic by calling `to_dict()` of regular_team
        if self.regular_team:
            _dict['regular_team'] = self.regular_team.to_dict()
        # override the default output from pydantic by calling `to_dict()` of globalmap
        if self.globalmap:
            _dict['globalmap'] = self.globalmap.to_dict()
        # override the default output from pydantic by calling `to_dict()` of epic
        if self.epic:
            _dict['epic'] = self.epic.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ranked_battles
        if self.ranked_battles:
            _dict['ranked_battles'] = self.ranked_battles.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ranked_10x10
        if self.ranked_10x10:
            _dict['ranked_10x10'] = self.ranked_10x10.to_dict()
        # set to None if all (nullable) is None
        # and model_fields_set contains the field
        if self.all is None and "all" in self.model_fields_set:
            _dict['all'] = None

        # set to None if company (nullable) is None
        # and model_fields_set contains the field
        if self.company is None and "company" in self.model_fields_set:
            _dict['company'] = None

        # set to None if stronghold_defense (nullable) is None
        # and model_fields_set contains the field
        if self.stronghold_defense is None and "stronghold_defense" in self.model_fields_set:
            _dict['stronghold_defense'] = None

        # set to None if stronghold_skirmish (nullable) is None
        # and model_fields_set contains the field
        if self.stronghold_skirmish is None and "stronghold_skirmish" in self.model_fields_set:
            _dict['stronghold_skirmish'] = None

        # set to None if clan (nullable) is None
        # and model_fields_set contains the field
        if self.clan is None and "clan" in self.model_fields_set:
            _dict['clan'] = None

        # set to None if random (nullable) is None
        # and model_fields_set contains the field
        if self.random is None and "random" in self.model_fields_set:
            _dict['random'] = None

        # set to None if fallout (nullable) is None
        # and model_fields_set contains the field
        if self.fallout is None and "fallout" in self.model_fields_set:
            _dict['fallout'] = None

        # set to None if team (nullable) is None
        # and model_fields_set contains the field
        if self.team is None and "team" in self.model_fields_set:
            _dict['team'] = None

        # set to None if regular_team (nullable) is None
        # and model_fields_set contains the field
        if self.regular_team is None and "regular_team" in self.model_fields_set:
            _dict['regular_team'] = None

        # set to None if globalmap (nullable) is None
        # and model_fields_set contains the field
        if self.globalmap is None and "globalmap" in self.model_fields_set:
            _dict['globalmap'] = None

        # set to None if epic (nullable) is None
        # and model_fields_set contains the field
        if self.epic is None and "epic" in self.model_fields_set:
            _dict['epic'] = None

        # set to None if ranked_battles (nullable) is None
        # and model_fields_set contains the field
        if self.ranked_battles is None and "ranked_battles" in self.model_fields_set:
            _dict['ranked_battles'] = None

        # set to None if frags (nullable) is None
        # and model_fields_set contains the field
        if self.frags is None and "frags" in self.model_fields_set:
            _dict['frags'] = None

        # set to None if in_garage (nullable) is None
        # and model_fields_set contains the field
        if self.in_garage is None and "in_garage" in self.model_fields_set:
            _dict['in_garage'] = None

        # set to None if ranked_10x10 (nullable) is None
        # and model_fields_set contains the field
        if self.ranked_10x10 is None and "ranked_10x10" in self.model_fields_set:
            _dict['ranked_10x10'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TanksStatsDataValueInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "account_id": obj.get("account_id"),
            "tank_id": obj.get("tank_id"),
            "all": TanksStatsDataValueInnerAll.from_dict(obj["all"]) if obj.get("all") is not None else None,
            "company": TanksStatsDataValueInnerCompany.from_dict(obj["company"]) if obj.get("company") is not None else None,
            "stronghold_defense": TanksStatsDataValueInnerStrongholdDefense.from_dict(obj["stronghold_defense"]) if obj.get("stronghold_defense") is not None else None,
            "stronghold_skirmish": TanksStatsDataValueInnerStrongholdSkirmish.from_dict(obj["stronghold_skirmish"]) if obj.get("stronghold_skirmish") is not None else None,
            "clan": TanksStatsDataValueInnerClan.from_dict(obj["clan"]) if obj.get("clan") is not None else None,
            "random": TanksStatsDataValueInnerRandom.from_dict(obj["random"]) if obj.get("random") is not None else None,
            "fallout": TanksStatsDataValueInnerFallout.from_dict(obj["fallout"]) if obj.get("fallout") is not None else None,
            "team": TanksStatsDataValueInnerTeam.from_dict(obj["team"]) if obj.get("team") is not None else None,
            "regular_team": TanksStatsDataValueInnerRegularTeam.from_dict(obj["regular_team"]) if obj.get("regular_team") is not None else None,
            "globalmap": TanksStatsDataValueInnerGlobalmap.from_dict(obj["globalmap"]) if obj.get("globalmap") is not None else None,
            "epic": TanksStatsDataValueInnerEpic.from_dict(obj["epic"]) if obj.get("epic") is not None else None,
            "ranked_battles": TanksStatsDataValueInnerRankedBattles.from_dict(obj["ranked_battles"]) if obj.get("ranked_battles") is not None else None,
            "max_xp": obj.get("max_xp"),
            "max_frags": obj.get("max_frags"),
            "frags": obj.get("frags"),
            "in_garage": obj.get("in_garage"),
            "mark_of_mastery": obj.get("mark_of_mastery"),
            "ranked_10x10": TanksStatsDataValueInnerRanked10x10.from_dict(obj["ranked_10x10"]) if obj.get("ranked_10x10") is not None else None
        })
        return _obj


